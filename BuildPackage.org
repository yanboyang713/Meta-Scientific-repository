
* Create own Arch Linux packages
This article aims to assist users creating their own packages using the Arch Linux "ports-like" build system.
It covers creation of a PKGBUILD – a package build description file sourced by makepkg to create a binary package from source.

* Overview
Packages in Arch Linux are built using the makepkg utility and the information stored in a PKGBUILD file. When makepkg runs, it searches for a PKGBUILD in the current directory and follows the instructions in it to acquire the required files and/or compile them to be packed within a package file (pkgname.pkg.tar.zst).

An Arch package is no more than a tar archive, or 'tarball', compressed using zstd, which contains the following files generated by makepkg:

+ The binary files to install.
+ .PKGINFO: contains all the metadata needed by pacman to deal with packages, dependencies, etc.
+ .BUILDINFO: contains information needed for reproducible builds.
+ .MTREE: contains hashes and timestamps of the files, which are included in the local database so that pacman can verify the integrity of the package.
+ .INSTALL: an optional file used to execute commands after the install/upgrade/remove stage. (This file is present only if specified in the PKGBUILD.)
+ .Changelog: an optional file kept by the package maintainer documenting the changes of the package. (It is not present in all packages.)

* Preparation
** Prerequisite software
First, ensure that the necessary tools are installed.

The package group *base-devel* should be sufficient, it includes make and additional tools needed for compiling from source.

#+begin_src console
yay -S base-devel
#+end_src

This is a good time to make sure the program is working correctly.

* Creating a PKGBUILD
When makepkg is run, it looks for a *PKGBUILD* file in the current working directory. If it finds one, it downloads the software's source code and compiles it according to the instructions specified in the PKGBUILD file.

The instructions must be fully interpretable by the Bash shell. After successful completion, the resulting binaries and metadata of the package, i.e. package version and dependencies, are packed in a *pkgname.pkg.tar.zst* package file. The newly created package can be installed by simply using *makepkg --install* which will call pacman in the background, or by directly using *pacman -U pkgname.pkg.tar.zst*.

To start building a new package, first create a new directory for the package and change current directory into this one.

Then, a PKGBUILD file needs to be created: a prototype PKGBUILD found in /usr/share/pacman/ can be used or you can start from a PKGBUILD from another package.

#+begin_src file
# This is an example PKGBUILD file. Use this as a start to creating your own,
# and remove these comments. For more information, see 'man PKGBUILD'.
# NOTE: Please fill out the license field for your package! If it is unknown,
# then please put 'unknown'.

# Maintainer: Your Name <youremail@domain.com>
pkgname=NAME
pkgver=VERSION
pkgrel=1
epoch=
pkgdesc=""
arch=()
url=""
license=('GPL')
groups=()
depends=()
makedepends=()
checkdepends=()
optdepends=()
provides=()
conflicts=()
replaces=()
backup=()
options=()
install=
changelog=
source=("$pkgname-$pkgver.tar.gz"
        "$pkgname-$pkgver.patch")
noextract=()
md5sums=()
validpgpkeys=()

prepare() {
	cd "$pkgname-$pkgver"
	patch -p1 -i "$srcdir/$pkgname-$pkgver.patch"
}

build() {
	cd "$pkgname-$pkgver"
	./configure --prefix=/usr
	make
}

check() {
	cd "$pkgname-$pkgver"
	make -k check
}

package() {
	cd "$pkgname-$pkgver"
	make DESTDIR="$pkgdir/" install
}

#+end_src

** Defining PKGBUILD variables
Example PKGBUILDs are located in /usr/share/pacman/. An explanation of possible PKGBUILD variables can be found in the PKGBUILD article.

makepkg defines two variables that you should use as part of the build and install process:

*srcdir*:
This points to the directory where makepkg extracts or symlinks all files in the source array.

*pkgdir*:
This points to the directory where makepkg bundles the installed package, which becomes the root directory of your built package.
They contain absolute paths, which means you do not have to worry about your working directory if you use these variables properly.

** PKGBUILD functions
When building a package, makepkg will invoke the following five functions if they have been defined in the PKGBUILD.

Function package() is required in every PKGBUILD and will always be invoked. If any of the other functions is not defined, makepkg will simply skip the invocation of that function.

During the build, the functions are invoked in the order in which they are listed here.

*** prepare()
With this function, commands that are used to prepare sources for building are run, such as patching. This function runs right after package extraction, before pkgver() and the build function. If extraction is skipped (makepkg --noextract), then prepare() is not run.

Note: (From PKGBUILD(5)) The function is run in bash -e mode, meaning any command that exits with a non-zero status will cause the function to exit.

*** pkgver()
pkgver() runs after the sources are fetched, extracted and prepare() executed. So you can update the pkgver variable during a makepkg stage.

This is particularly useful if you are making git/svn/hg/etc. packages, where the build process may remain the same, but the source could be updated every day, even every hour. The old way of doing this was to put the date into the pkgver field which, if the software was not updated, makepkg would still rebuild it thinking the version had changed. Some useful commands for this are git describe, hg identify -ni, etc. Please test these before submitting a PKGBUILD, as a failure in the pkgver() function can stop a build in its tracks.

Note: pkgver cannot contain spaces or hyphens (-). Using sed to correct this is common.

*** build()
Now you need to implement the build() function in the PKGBUILD file. This function uses common shell commands in Bash syntax to automatically compile software and create a directory called pkg to install the software to. This allows makepkg to package files without having to sift through your file system.

The first step in the build() function is to change into the directory created by uncompressing the source tarball. makepkg will change the current directory to $srcdir before executing the build() function. Therefore, in most cases, like suggested in /usr/share/pacman/PKGBUILD.proto, the first command will look like this:

#+begin_src bash

cd "$pkgname-$pkgver"
#+end_src

Now, you need to list the same commands you used when you manually compiled the software. The build() function in essence automates everything you did by hand and compiles the software in the fakeroot build environment. If the software you are packaging uses a configure script, it is good practice to use --prefix=/usr when building packages for pacman. A lot of software installs files relative to the /usr/local directory, which should only be done if you are manually building from source. All Arch Linux packages should use the /usr directory. As seen in the /usr/share/pacman/PKGBUILD.proto file, the next two lines often look like this:

#+begin_src bash

./configure --prefix=/usr
make
#+end_src

Note: If your software does not need to build anything, do not use the build() function. The build() function is not required, but the package() function is.

*** check()
Place for calls to make check and similar testing routines. It is highly recommended to have check() as it helps to make sure software has been built correctly and works fine with its dependencies.

Users who do not need it (and occasionally maintainers who can not fix a package for this to pass) can disable it using BUILDENV+=('!check') in PKGBUILD/makepkg.conf or call makepkg with --nocheck flag.

*** package()
The final step is to put the compiled files in a directory where makepkg can retrieve them to create a package. This by default is the pkg directory—a simple fakeroot environment. The pkg directory replicates the hierarchy of the root file system of the software's installation paths. If you have to manually place files under the root of your filesystem, you should install them in the pkg directory under the same directory structure. For example, if you want to install a file to /usr/bin, it should instead be placed under $pkgdir/usr/bin. Very few install procedures require the user to copy dozens of files manually. Instead, for most software, calling make install will do so. The final line should look like the following in order to correctly install the software in the pkg directory:

#+begin_src bash
make DESTDIR="$pkgdir/" install
#+end_src

Note: It is sometimes the case where DESTDIR is not used in the Makefile; you may need to use prefix instead. If the package is built with autoconf / automake, use DESTDIR; this is what is documented in the manuals. If DESTDIR does not work, try building with make prefix="$pkgdir/usr/" install. If that does not work, you will have to look further into the install commands that are executed by "make <...> install".
makepkg --repackage runs only the package() function, so it creates a package without building. This may save time e.g. if you have changed just the depends variable of the package.

* Testing the PKGBUILD and package
As you are writing the build() function, you will want to test your changes frequently to ensure there are no bugs. You can do this using the makepkg command in the directory containing the PKGBUILD file. With a properly formatted PKGBUILD, makepkg will create a package; with a broken or unfinished PKGBUILD, it will raise an error.

If makepkg finishes successfully, it will place a file named pkgname-pkgver.pkg.tar.zst in your working directory. This package can be installed with the pacman -U command. However, just because a package file was built does not imply that it is fully functional. It might conceivably contain only the directory and no files whatsoever if, for example, a prefix was specified improperly. You can use pacman's query functions to display a list of files contained in the package and the dependencies it requires with pacman -Qlp [package file] and pacman -Qip [package file] respectively.

If the package looks sane, then you are done! However, if you plan on releasing the PKGBUILD file, it is imperative that you check and double-check the contents of the depends array.

Also ensure that the package binaries actually run flawlessly! It is annoying to release a package that contains all necessary files, but crashes because of some obscure configuration option that does not quite work well with the rest of the system. If you are only going to compile packages for your own system, though, you do not need to worry too much about this quality assurance step, as you are the only person suffering from mistakes, after all.

Checking package sanity
After testing package functionality check it for errors using namcap:

$ namcap PKGBUILD
$ namcap <package file name>.pkg.tar.zst
Namcap will:

Check PKGBUILD contents for common errors and package file hierarchy for unnecessary/misplaced files
Scan all ELF files in package using ldd, automatically reporting which packages with required shared libraries are missing from depends and which can be omitted as transitive dependencies
Heuristically search for missing and redundant dependencies
and much more.

Get into the habit of checking your packages with namcap to avoid having to fix the simplest mistakes after package submission.

* Summary
1. Download the source tarball of the software to package.
2. Try compiling the package and installing it into an arbitrary directory.
3. Copy over the prototype /usr/share/pacman/PKGBUILD.proto and rename it to PKGBUILD in a temporary working directory.
4. Edit the PKGBUILD according to the needs of your package.
5. Run makepkg and check whether the package builds correctly.
6. If not, repeat the previous two steps.
** Warnings
Before you can automate the package building process, you should have done it manually at least once unless you know exactly what you are doing in advance, in which case you would not be reading this in the first place. Unfortunately, although a good bunch of program authors stick to the 3-step build cycle of "./configure; make; make install", this is not always the case, and things can get real ugly if you have to apply patches to make everything work at all. Rule of thumb: If you cannot get the program to compile from the source tarball, and make it install itself to a defined, temporary subdirectory, you do not even need to try packaging it. There is not any magic pixie dust in makepkg that makes source problems go away.
In a few cases, the packages are not even available as source and you have to use something like sh installer.run to get it to work. You will have to do quite a bit of research (read READMEs, INSTALL instructions, man pages, perhaps ebuilds from Gentoo or other package installers, possibly even the MAKEFILEs or source code) to get it working. In some really bad cases, you have to edit the source files to get it to work at all. However, makepkg needs to be completely autonomous, with no user input. Therefore if you need to edit the makefiles, you may have to bundle a custom patch with the PKGBUILD and install it from inside the prepare() function, or you might have to issue some sed commands from inside the prepare() function.
